# 13-1 闭包

## 闭包

js中，我已经对闭包很熟悉了，因此这里省略很多内容。

在JS中，闭包是一种思维，一种形式，凡是通过**返回函数捕获其创建时的作用域**的方式，我们称这里形成了闭包。

**但是在Rust中，闭包被特定指明为——简短的匿名函数**。

不废话的说：**在Rust中，闭包就是函数，简短的匿名函数**。

具体定义如下：

> Rust 的 闭包（closures）是可以保存进变量或作为参数传递给其他函数的匿名函数。可以在一个地方创建闭包，然后在不同的上下文中执行闭包运算。不同于函数，闭包允许捕获调用者作用域中的值。我们将展示闭包的这些功能如何复用代码和自定义行为。

所有的闭包都至少实现了以下之一的 Trait ：

```text
Fn
FnMut
FnOnce
```

## RUST 中闭包的写法

```rust
fn  add_one_v1   (x: u32) -> u32 { x + 1 }  // 一个函数
let add_one_v2 = |x: u32| -> u32 { x + 1 }; // 完整的闭包写法
let add_one_v3 = |x|             { x + 1 }; // 省略参数注解的闭包写法
let add_one_v4 = |x|               x + 1  ; // 当闭包中只有一个表达式时省略花括号
```

## 闭包的类型推断

这里需要重点提一下。

**闭包通常很短**，涉及一些细小的功能，如果你的闭包写的很复杂，请考虑设计成一个函数。

闭包不要求在参数列表和返回值上注明类型，因为闭包通常是短小精炼的，可以通过上下文推断出类型，并且要注意的是，闭包内的类型一旦被推断出来，就不会改变。下面的例子中，x被推断为 String 类型，因此第三行传入 5 会报错。

```rust
let example_closure = |x| x;

let s = example_closure(String::from("hello"));
let n = example_closure(5); // error, 5 is not String type
```

## 使用闭包做缓存

官方教程是使用了一个健身的例子，我在这里就不说那么麻烦了，并且官方的介绍在这里很不妥当，因为在Jsinfo的文档中提到，这种缓存适用于**输出固定**、**计算耗时**的函数，在本例的原意中，其实并不满足第一点，因此总觉得很怪。

大致思路是，当我们遇到一个计算耗时的函数时，其实并没有必要每次调用都计算一次，在计算第一次之后可以把结果缓存起来，再一次调用的时候可以直接拿出来结果使用。

```rust
//这里定义了一个结构体，并且要给结构体添加trait，是一个函数类型的trait，且必须注明参数和返回值
struct Cacher<T: Fn(u32) -> u32> {
    exp: T,
    //value我们用一个Option表示，初始为None，如果有值就为Some
    value: Option<u32>,
}

//实现的时候也要加标注
impl<T: Fn(u32) -> u32> Cacher<T> {
    //定义构造函数，value初始为None
    fn new (exp: T) -> Cacher<T> {
        Cacher {
            exp,
            value: None,
        }
    }
    //实现value函数，当自身的value是Some时，说明已经有值，不再计算；为None时计算并赋值
    fn value (&mut self, arg: u32) -> u32{
        match self.value {
            Some(v) => v,
            None => {
                let v = (self.exp)(arg);
                self.value = Some(v);
                v
            }
        }
    }
}

fn main () {
    //把闭包作为参数传入Cacher的构造函数
    let mut high_expensive_cacher  = Cacher::new(|num| {
        println!("calculating ... {}", num);
        thread::sleep(Duration::from_secs(3));
        println!("solved!");
        num * 2
    });
    high_expensive_cacher.value(intensity);
}
```

上面的做法相当于加了一层缓存，对于复杂计算的函数可以这么处理（我感觉有点不至于其实，用hashmap可以直接做到）。

这么做的缺点：

* 在给闭包对应的字段添加 Trait 时，需要注明函数参数类型，以及返回值类型，限制了传入闭包的自由度。比如在上面的例子中这个`Cacher` 只能处理 `Fn(u32) -> u32` 的闭包。

## 闭包会捕获创建时的环境

这个就不展开说了，Js比这个更复杂。讲点Rust独有的。

**闭包可以通过三种方式捕获其环境**，他们直接对应函数的三种获取参数的方式：**获取所有权**，**可变借用和不可变借用**。这三种捕获值的方式被编码为如下三个 `Fn` trait：

* `FnOnce` 消费从周围作用域捕获的变量，闭包周围的作用域被称为其 环境，environment。为了消费捕获到的变量，闭包必须获取其所有权并在定义闭包时将其移动进闭包。其名称的 Once 部分代表了闭包不能多次获取相同变量的所有权的事实，所以它只能被调用一次。
* `FnMut` 获取可变的借用值所以可以改变其环境
* `Fn` 从其环境获取不可变的借用值

当创建一个闭包时，Rust 根据其如何使用环境中变量来推断我们希望如何引用环境。由于所有闭包都可以被调用至少一次，所以所有闭包都实现了 `FnOnce` 。那些并没有移动被捕获变量的所有权到闭包内的闭包也实现了 `FnMut` ，而不需要对被捕获的变量进行可变访问的闭包则也实现了 `Fn` 。 在健身提醒例子中，闭包不可变的借用了 `intensity`（所以具有 `Fn` trait），因为闭包体只需要读取 `intensity` 的值。

如果你希望强制闭包获取其使用的环境值的所有权，可以在参数列表前使用 move 关键字。这个技巧在将闭包传递给新线程以便将数据移动到新线程中时最为实用。

第十六章讨论并发时会展示更多 move 闭包的例子，下面的例子第三行会报错，因为`x`的所有权移入了闭包中。

```rust
let x = vec![1, 2, 3];
let equal_to_x = move |z| z == x;
println!("can't use x here: {:?}", x);
```

## 关于闭包Trait 类型的最佳实践

上面提到了闭包有三种 Trait，

* `FnOnce`
* `FnMut`
* `Fn`

**官方给出的最佳实践是，直接使用 `Fn` Trait，如果不合适，编译器会主动提醒你是否需要 `FnMut` 或 `FnOnce`** ！

我们Rust 实在是太智能了，真的是绝绝子😅

为了展示闭包作为函数参数时捕获其环境的作用，让我们继续下一个主题：迭代器。

