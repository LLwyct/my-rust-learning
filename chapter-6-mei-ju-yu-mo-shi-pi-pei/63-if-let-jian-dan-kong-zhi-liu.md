# 6-3 if let 简单控制流

## if let 简单控制流

`if let` 语法让我们以一种不那么冗长的方式结合 `if` 和 `let`。

先用经典 `match` 来实现一个只匹配 `some(3)`：

```typescript
let a = Some(3);
match a {
    Some(3) => println!("three"),
    _ => (),
}
```

但是可以看出我不希望处理任何其他整数或None，因此可以使用 `if let` 这种更短的写法：

```typescript
// 这里确实只有一个等号
if let Some(3) = a {
    println!("three")
}
```

## 总结

现在我们涉及到了如何使用枚举来创建有一系列可列举值的自定义类型。我们也展示了标准库的 `Option<T>` 类型是如何帮助你利用类型系统来避免出错的。当枚举值包含数据时，你可以根据需要处理多少情况来选择使用 `match` 或 `if let` 来获取并使用这些值。

你的 Rust 程序现在能够使用结构体和枚举在自己的作用域内表现其内容了。在你的 API 中使用自定义类型保证了类型安全：编译器会确保你的函数只会得到它期望的类型的值。

为了向你的用户提供一个组织良好的 API，它使用起来很直观并且只向用户暴露他们确实需要的部分，那么现在就让我们转向 Rust 的模块系统吧。

