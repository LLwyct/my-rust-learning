# 16-4 使用 Sync 和 Send trait 的可扩展并发

Rust 语言**本身**的并发特性较少，目前将的并发特性都来自标准库（而不是语言本身）

并发方案不受标准库或语言，可以自己实现并发，可以编写自己的或使用别人编写的并发功能。

然而有两个并发概念是内嵌于语言中的：`std::marker` 中的 `Sync` 和 `Send` trait。它们两个是标签Trait，因为没有定义任何方法。

## Send：允许线程间转移所有权

* Rust 中几乎所有类型都实现了 `Send` Trait。但 `Rc<T>` 没有，它只适用于单线程。
* 任何完全有Send类型组成的类型，也被标记为Send。
* 除了原始指针之外，几乎所有类型都实现了 Send。

## Sync：允许被多线程同时访问

* 实现了Sync 的类型可以安全的被多个线程引用。
* 也就是说，如果T 是Sync，那么 &T 就是Send，引用可以被安全的送往另一个线程。
* 基础类型都是Sync。
* 完全由Sync类型组成的类型也是Sync
  * 但 `Rc<T`&gt; 不是Sync 的
  * `RefCell<T>`和`Cell<T>`家族也不是Sync的
  * 而`Mutex<T>`是Sync的。

## 手动实现 Send 和 Sync 是不安全的

> 通常并不需要手动实现 Send 和 Sync trait，因为由 Send 和 Sync 的类型组成的类型，自动就是 Send 和 Sync 的。因为他们是标记 trait，甚至都不需要实现任何方法。他们只是用来加强并发相关的不可变性的。
>
> 手动实现这些标记 trait 涉及到编写不安全的 Rust 代码，第十九章将会讲述具体的方法；当前重要的是，在创建新的由不是 Send 和 Sync 的部分构成的并发类型时需要多加小心，以确保维持其安全保证。[The Rustonomicon](https://doc.rust-lang.org/stable/nomicon/) 中有更多关于这些保证以及如何维持他们的信息。

## 总结

这不会是本书最后一个出现并发的章节：第二十章的项目会在更现实的场景中使用这些概念，而不像本章中讨论的这些小例子。

正如之前提到的，因为 Rust 本身很少有处理并发的部分内容，有很多的并发方案都由 crate 实现。他们比标准库要发展的更快；请在网上搜索当前最新的用于多线程场景的 crate。

Rust 提供了用于消息传递的通道，和像 `Mutex<T>` 和 `Arc<T>` 这样可以安全的用于并发上下文的智能指针。类型系统和借用检查器会确保这些场景中的代码，不会出现数据竞争和无效的引用。一旦代码可以编译了，我们就可以坚信这些代码可以正确的运行于多线程环境，而不会出现其他语言中经常出现的那些难以追踪的 bug。并发编程不再是什么可怕的概念：无所畏惧地并发吧！

接下来，让我们讨论一下当 Rust 程序变得更大时，有哪些符合语言习惯的问题建模方法和结构化解决方案，以及 Rust 的风格是如何与面向对象编程（Object Oriented Programming）中那些你所熟悉的概念相联系的。

